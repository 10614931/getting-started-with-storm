[[spouts]]
== Spouts

In this chapter weâ€™ll see the most used strategies to design the entry point of our topologies (spouts) and how we can do these spouts fault-tolerant

=== Reliable vs Unreliable messages

When we design a topology one important thing to take in mind is the message reliable, in other words when a message can't be processed we need to decide what we'll do with the message and what we'll do with the topology, for example if we are processing bank deposit, we can't lost any transaction message but if we are processing millons of tweets looking for some statistic metric and we lost one tweet we can assume that the metric will be ok.

(**************************************No estoy muy seguro del parafo que viene*************************************************)
In storm is our responsability the guaranteeing messages and depends on needs of each topology to do these more or less reliable, because each one have their trade-off's, if we do a very reliable topology we must manage the lost messages and probably this use much resources, in the other hand if we decide to have an unreliable topology we will take the caution that if a message is fail we can't do anything.

To manage the reliable in the spout, we can send with our tuple a message id to identify this tuple at the _emit_ time (*collector.emit(new Values(...),tupleId)*), if we do that, we'll be able to use the methods *ack* and *fail* that will be called if a tuple is proceced correctly or if this fail respectively, the fail method could be called if the *collector.fail(tuple)* is called into the target spouts or if the tuple excedes the Config.TOPOLOGY_MESSAGE_TIMEOUT_SECS (max number of seconds before the tuple is full processed) or Config.TOPOLOGY_MAX_SPOUT_PENDING (number of tuples emited without get ack or fail) topology parameters

TIP: A tuple with a message id will be full processed when: the tuple has been processed by all target bolts and all bolts anchored to the tuple (if there) have processed this tuple too (we will see how anchore a bolt to a tuple into the chapter <<bolts,Bolts>>)

We will use the bank example to resend a transaction if something fails processing it and we fail if we receive 2 errors processing one transaction. To do that we'll create an Spout that will send 100 random transactions Ids and an bolt that will fail 80% of the tuples received (you can found the complete example at link:https://github.com/storm-book/examples/tree/master/ch04-spouts[ch04-spout examples]) 
To emit the tuples will use a _Map_ where we'll put all the transaction message that we want to send so it will make very easy re-send messages.

[source, java]
----
public void nextTuple() {
    if(!toSend.isEmpty()){
        for(Map.Entry<Integer, String> transactionEntry : toSend.entrySet()){
            Integer transactionId = transactionEntry.getKey();
            String transactionMessage = transactionEntry.getValue();
            collector.emit(new Values(transactionMessage),transactionId);
        }
        toSend.clear();
    }
    try {
        Thread.sleep(1);
    } catch (InterruptedException e) {}
}
----
Where we take all messages at the *toSend*" map and emit these using the transaction id as message id to re-send it if is needed, we can use the *clear* method safety because the fail method and the ack method where will modify the map run in the same thread-loop

Our ack method will be very simple, because the only thing that we need to do it's remove the message from our message list, as we can see below

[source, java]
----
public void ack(Object msgId) {
    messages.remove(msgId);
}
----

At the end we'll see our *fail* where we decide if we must finish the topology (because we found many errors) or we shoud re-send the message
[source, java]
----
public void fail(Object msgId) {
    Integer transactionId = (Integer) msgId;
    //Get the transactions fails
    Integer fails = failCounterMessages.get(transactionId) + 1;
    
    if(fails >= MAX_FAILS){
        //If exceeds the max fails will go down the topology
        throw new RuntimeException("Error, transaction id ["+transactionId+"] has had many errors ["+fails+"]");
    }
    
    //If not exceeds the max fails we save the new fails quantity and re-send the message 
    failCounterMessages.put(transactionId, fails);
    toSend.put(transactionId,messages.get(transactionId));
    LOG.info("Re-sending message ["+msgId+"]");
}
----



TIP: It's important to know that storm is a fast-fail system, if we throw an un-catch exeption, we'll go down our topology but If some process goes down storm we'll be able to recovery the correctly when the process is restarted
