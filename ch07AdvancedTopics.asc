[[advanced_topics]]
== Advanced Topics
[[using_non_jvm_languages_with_storm]]
=== Using non JVM languages with Storm

Sometimes we want to use other languages, not based on JVM, to implement our bolt and spouts, either because we feel more confortable in that languages or because we want to reuse some code we already wrote in that language.
As you already read, storm has been implemented in java and all the spouts and bolts implemented along the book were written in java as well. So is it possible to use languages like python, ruby or even javascript to do our spouts and bolts?
The answer to this question is yes! It is possible through something called *multilang protocol*. Although in the current stable versions of storm only bolts can be implemented in non-jvm languages. Support for spout is comming in next versions.

The multilang protocol is a special protocol implemented in storm that uses standard input and output as a channel of communication with a process that will be doing all the job of the bolt. Messages will come and go through this channel. These messages will be regular string lines and JSON encoded messages.
It is also necessary to create a small shell in java to the bolt we want to be implemented in some other language. This shell is just a way to tell storm how to run the script that will do the job and that can be implemented in php, perl, ruby, python, etc.

Lets see a very basic example of how to write a bolt in a non-jvm language. We will have a spout that generates numbers from 1 to 10000 written in java and a single bolt, written in PHP, that will filter thos numbers that are prime numbers.

TIP: In this example we use a very basic and naive way of finding out if a number is a prime number. There are much better implementations, but are also more complex and out of the scope of this example.

First of all we define our topology.

[source, java]
----
...
TopologyBuilder builder = new TopologyBuilder();
builder.setSpout("numbers-generator", new NumbersGeneratorSpout(1, 10000));
builder.setBolt("prime-numbers-filter", new PrimeNumbersFilterBolt(), 1).shuffleGrouping("numbers-generator");
StormTopology topology = builder.createTopology();
...
----

Nothing new here. Lets see the implementation of +NumbersGeneratorSpout+ just to complete the example.

[source, java]
----
public class NumbersGeneratorSpout implements IRichSpout {
    private static final long serialVersionUID = -2907937018266991175L;
    private SpoutOutputCollector collector;
    private Integer from;
    private Integer to;

    public NumbersGeneratorSpout(Integer from, Integer to) {
        this.from = from;
        this.to = to;
    }

    public void declareOutputFields(OutputFieldsDeclarer declarer) {
        declarer.declare(new Fields("number"));
    }

    public boolean isDistributed() {
        return false;
    }

    public void open(Map conf, TopologyContext context,
            SpoutOutputCollector collector) {
        this.collector = collector;
    }

    public void close() {
    }

    public void nextTuple() {
        if (this.from <= this.to) {
            List<Object> values = new ArrayList<Object>();
            values.add(this.from++);
            collector.emit(values);
        }
    }

    public void ack(Object msgId) {
    }

    public void fail(Object msgId) {
    }
}
----

Also nothing very important here. The spout will generate sequential numbers starting with the *from* parameter and up to the *to* paremeter given in the constructor.

Next let's see what is +PrimeNumbersFilterBolt+. This class is the shell we've been talking about. It is the way to tell storm how to execute our PHP script.
Storm provides a speciall class for that called +ShellBolt+ where the only thing we have to do is to indicate how to run the script and declare the fields that will be emitted by the script.

Lets see the implementation of our example.

[source, java]
----
public class PrimeNumbersFilterBolt extends ShellBolt implements IRichBolt {
    public PrimeNumbersFilterBolt() {
        super("php", "-f", "PrimeNumbersFilterBolt.php");
    }

    public void declareOutputFields(OutputFieldsDeclarer declarer) {
        declarer.declare(new Fields("number"));
    }
}
----

We can see here that in the constructor that we are telling storm how the run the php script. This is the equivalent of doing in bash:

[source, bash]
----
php -f PrimeNumbersFilterBolt.php
----

This PrimeNumbersFilterBolt php script will basically read tuples from standard input, process them, and emit, ack or fail through standard output.

Before going over the implementation of +PrimeNumbersFilterBolt.php+ script lets see more in the details how the multilang protocol works.

[[multilang_protocol_spec]]
==== Multilang Protocol Specification

As we said previously this protocol relies on standard input and standard output as a channel of communication between processes.
There is a list of steps that your script needs to follow in order to work.
Lets see them and explain them in details.

1. Create the heartbeat file.
2. Read topology configuration.
3. Read context configuration.
4. Start looping, read tuples, process them and emit/ack/fail.

TIP: There is a special way of logging from your script. This way storm will take the message you are logging and log it with his own mechanism so you don't need to have a special log file of your script.

Lets see in details how each step works. And we'll see it also how we implemented this in our PHP script.

1. Create the heartbeat file.

In order to be able to control the process (starting and stoping it), storm needs to know tha PID (process id) of the script it is executing. As the multilang protocol says, the very first thing that will happen when our process start is that storm will send to the standard input a string line (a string terminated with +\n+) with the path where the process should create an empty file named as the PID of the process.
So for example if we receive +/tmp/example\n+ and the PID of our script is +123+, we should create an empty file +/tmp/example/123+ and also print the line +123\n+ in our standard output.
This is the way storm gets our PID and can kill our process when it shutsdown.
Lets see how we did this in PHP.

[source, php]
----
$heartbeatdir = read_msg();
$pid = getmypid();
fclose(fopen("$heartbeatdir/$pid", "w"));
echo "$pid\n";
flush();
----

This code is very simple. We've created a function called +read_msg+ to handle reading messages from standard input. The multilang protocol states that messages can be single line strings or multiple lines JSON encoded messages. The way to know when a message is complete is when you read a sinle line string +end\n+.
So lets see how we've implemented this in PHP.

[source, php]
----
function read_msg() {
    $msg = "";
    while(true) {
        $line = substr(fgets(STDIN),0,-1);
        if($line=="end") {
            break;
        }
        $msg = "$msg$line\n";
    }
    return substr($msg, 0, -1);
}
----

TIP: The use of +flush()+ is very important as there might be a buffer that won't be flushed until a specific amount of characters have been accumulated. This mean that your script can hang forever waiting for an input from storm, which won't happen because storm is waiting an output from your script. So it is important to make sure that when your script outputs something it gets flushed immediately.

2. Read topology configuration.
3. Read context configuration.

After we've created the heardbeat file and flushed out PID, storm will send us both topology and context configuration. This is basically all the configurations that might be important to know, parameters we've set for the bolts and spouts, the topology itself, etc. In this very basic example we don't use it. But still we need to read it.
Since we've implemented a +read_msg()+, it is fairly easy to do that.

[source, php]
----
$topology = read_msg();
$context = read_msg();
----

TIP: Both configurations will come encoded as JSON messages. So we'll need to decode it in order to use it.

4. Start looping, read tuples, process them and emit/ack/fail.

This is the most important step and where all the work gets done. Although it is pretty simple and straightforward.
The script at this stage is prepared to start processing tuples. So storm will start sending them, one by one, through the standard input. In order to make sure the script is ready for the next tuple, storm will wait for a single line string +sync\n+ between every tuple. So until we don't print that to the standard output, storm won't send the next tuple.
Reading the tuple from standard input is very simple. We just call our +read_msg()+ function and then we json decode it.

[source, php]
----
$json = read_msg();
$tuple = json_decode($json, true, 512, JSON_BIGINT_AS_STRING);
----

TIP: The use of JSON_BIGINT_AS_STRING in the json_decode function is a workaround to a conversion problem between java and php. Java will send very big and small numbers and in PHP they will get decoded with less precision which will make our communication fail. So a way to workaround this problem is by decoding very big or low numbers as string. When we print a json message with that number, we just avoid using double quotes. Since we are using 5.4.0 or higher.

After reading and decoding our tuple, the next step is to check if the number sended in the tuple is prime or not and then decide if we emit or not the number to the stream.
Messages like emit, ack, fail or log have the following structure:

===== Emit

[source, json]
----
{
    "command": "emit",
    "tuple": ["foo", "bar"]
}
----

Where the array has the values we are emitting for the tuple.

===== Ack

[source, json]
----
{
    "command": "ack",
    "id": 123456789
}
----

Where the +id+ is the id of the tuple we are processing.

===== Fail

[source, json]
----
{
    "command": "fail",
    "id": 123456789
}
----

Same as emit, the +id+ is the id of the tuple we are processing.

===== Log

[source, json]
----
{
    "command": "log",
    "msg": "some message to be logged by storm."
}
----

Lets see more in detail how we have implemented this loop in our PHP script.

[source, php]
----
while(true) {
    $json = read_msg();
    $tuple = json_decode($json, true, 512, JSON_BIGINT_AS_STRING);
    if(isPrime($tuple["tuple"][0])) {
        storm_log("forwarding ".$tuple["tuple"][0]);
        storm_emit(array($tuple["tuple"][0]));
    } else {
        storm_log("discarding ".$tuple["tuple"][0]);
    }
    storm_ack($tuple["id"]);
    storm_sync();
}
----

We check if the number in the tuple is prime, if that is true we emit it, otherwise we just log that we are discarding it. In both cases we ack and sync, after which storm will send the next tuple and we'll be able to read it from our standard input.

Lets see now the entire PHP script.

[source, php]
----
<?php
function isPrime($number) {
    if ($number < 2) {
        return false;
    }
    for ($i=2; $i<=($number / 2); $i++) {
        if($number % $i == 0) { 
            return false;
        }
    }
    return true;
}

function read_msg() {
    $msg = "";
    while(true) {
        $line = substr(fgets(STDIN),0,-1);
        if($line=="end") {
            break;
        }
        $msg = "$msg$line\n";
    }
    return substr($msg, 0, -1);
}

function storm_send($json) {
    write_line(json_encode($json));
    write_line("end");
}


function storm_ack($id) {
    write_line('{"command":"ack", "id":'.$id.'}');
}

function write_line($line) {
    echo("$line\n");
}

function storm_sync() {
    write_line("sync");
    flush();
}

function storm_emit($tuple) {
    $msg = array("command" => "emit", "tuple" => $tuple);
    storm_send($msg);
}

function storm_log($msg) {
    $msg = array("command" => "log", "msg" => $msg);
    storm_send($msg);
    flush();
}

$heartbeatdir = read_msg();
$pid = getmypid();
fclose(fopen("$heartbeatdir/$pid", "w"));
echo "$pid\n";
flush();

$topology = read_msg();
$context = read_msg();

while(true) {
    $json = read_msg();
    $tuple = json_decode($json, true, 512, JSON_BIGINT_AS_STRING);
    if(isPrime($tuple["tuple"][0])) {
        storm_log("forwarding ".$tuple["tuple"][0]);
        storm_emit(array($tuple["tuple"][0]));
    } else {
        storm_log("discarding ".$tuple["tuple"][0]);
    }
    storm_ack($tuple["id"]);
    storm_sync();
}
?>
----

It is very important to put all these scripts in a special folder +multilang/resources+ in our project directory. This folder will get included in our jar file and be sent to the workers. If we don't put out scripts in that folder, storm won't be able to run the scripts and will give an error message accordingly.

[[testing_our_topology]]
=== Testing our Topology
Some text...
