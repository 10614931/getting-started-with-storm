[[topologies]]
== Topologies
In this chapter we'll see more in depth how all our objects are glued and how we can do to deploy our topology into a running storm cluster

=== Streams Grouping 
Ones of the most important things that we need to do when we design a topology is define how the data will be exchanged between the nodes (how the streams will be consumed by the nodes), to do that we'll use the streams grouping which can be set to an *InputDeclarer*, with these streams groping we'll specify which stream will be consumed by the input declarer (normaly the input declared will be the representation of our bolts into the topology) and how the stream will be consumed. 

The way to set the streams grouping will be in the topology definition as we have saw in the <<getting_started,Getting Started>> chapter:

[source, java]
----
....
    builder.setBolt("word-normalizer", new WordNormalizer())
        .shuffleGrouping("word-reader");
....
----
Where we set a new bolt to the topology builder (the builder object) and after that we add a new source using some stream grouping, shuffleGrouping in this case. Depends on the grouping kind this will take diferent amount of parameters but normally the grouping will take the component id source, where consume the stream.

TIP: We can have more than one source per each *InputDeclarer* and each source could be grouped with a different stream grouping

==== Shuffle Grouping
We can label the Shuffle Grouping as the default grouping. As we saw into the example this grouping only take one parameter (the source componente), with this grouping each tuple emited by the source will be send in a randomly fashion to the bolt without have the capacity of control what tuple is sent to each bolt. 

The shuffle grouping is excellent when we need to do atomic operations, for example, if we need to do a math operation with the data of tuple and emit the result, is very probable that we want use a Shuffle Grouping but if we need count words, we can’t use this because we’ll need to save state (in this case the word) to count it and as we saw in the chapter 2 is very probable that one word will be received by two bolts and the word will be counted in more than one time.

==== Fields Grouping
The Fields Grouping enable us to control how the tuples are sent to the bolts based on one or more field of the tuple, this grouping will guarantee us that ever than a combination of values of the fields specified in a tuple would be repeated, this tuple will be sent to the same bolt. Comming back to the count word example, if we specify as grouping the field "word" (like we can see below) we'll make that ever the *word-normalizer* bolt send a tuple with one word, this word will be send to the same instance of *word-counter* bolt.

[source,java]
----
....
builder.setBolt("word-counter", new WordCounter(),2)
    .fieldsGrouping("word-normalizer", new Fields("word"));
....
----

TIP: All fields set into the fields grouping must be exist into the sources's fields declarer

==== All Grouping
text

==== Custom Grouping
text

==== Other groupings
text

=== LocalCluster vs StormSubmitter
text

=== Monitoring a Topology
text

=== DRPC Topologies
text

=== Conclusions
text

