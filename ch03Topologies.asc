[[topologies]]
== Topologies
In this chapter we'll see more in depth how all our objects are glued and how we can do to deploy our topology into a running storm cluster

=== Streams Grouping 
Ones of the most important things that we need to do when we design a topology is define how the data will be exchanged between the nodes (how the streams will be consumed by the nodes), to do that we'll use the streams grouping which can be set to an *InputDeclarer*, with these streams groping we'll specify which stream will be consumed by the input declarer (normaly the input declared will be the representation of our bolts into the topology) and how the stream will be consumed. 

TIP: One node could emit more than one *stream* of data, the streams grouping enable us to select what stream we want to receive if we have more than one.

The way to set the streams grouping will be in the topology definition as we have saw in the <<getting_started,Getting Started>> chapter:

[source, java]
----
....
    builder.setBolt("word-normalizer", new WordNormalizer())
        .shuffleGrouping("word-reader");
....
----
Where we set a new bolt to the topology builder (the builder object) and after that we add a new source using some stream grouping, shuffleGrouping in this case. Depends on the grouping kind this will take diferent amount of parameters but normally the grouping will take the component id source, where consume the stream.

TIP: We can have more than one source per each *InputDeclarer* and each source could be grouped with a different stream grouping

==== Shuffle Grouping
We can label the Shuffle Grouping as the default grouping. As we saw into the example this grouping only take one parameter (the source componente), with this grouping each tuple emited by the source will be send in a randomly fashion to the bolt without have the capacity of control what tuple is sent to each bolt. 

The shuffle grouping is excellent when we need to do atomic operations, for example, if we need to do a math operation with the data of tuple and emit the result, is very probable that we want use a Shuffle Grouping but if we need count words, we can’t use this because we’ll need to save state (in this case the word) to count it and as we saw in the chapter 2 is very probable that one word will be received by two bolts and the word will be counted in more than one time.

==== Fields Grouping
The Fields Grouping enable us to control how the tuples are sent to the bolts based on one or more field of the tuple, this grouping will guarantee us that ever than a combination of values of the fields specified in a tuple would be repeated, this tuple will be sent to the same bolt. Comming back to the count word example, if we specify as grouping the field "word" (like we can see below) we'll make that ever the *word-normalizer* bolt send a tuple with one word, this word will be send to the same instance of *word-counter* bolt.

[source,java]
----
....
builder.setBolt("word-counter", new WordCounter(),2)
    .fieldsGrouping("word-normalizer", new Fields("word"));
....
----

TIP: All fields set into the fields grouping must be exist into the sources's fields declarer

==== All Grouping
This group will do an *explode* of the infomation sending the touple to all instances of the bolt that require the stream, it's mean that when we use the *All Groping* one copy of the tuple will be receive by each instance of the bolt. This kind of groping is perfect when we need to send *signals* to our bolts, for example if we need refresh a cache we can send a *refresh cache signal* to our bolts. Here we can see the example modifing the word-count add the capability of clear the *counter* cache (we can found this example running at link:https://github.com/storm-book/examples-ch03-topologies[Topologies Example])

Here we have the mofification to the word-counter bolt:
[source,java]
----
public void execute(Tuple input) {
            String str = null; 
            try{
                str = input.getStringByField("word");
            }catch (IllegalArgumentException e) {
                //Do nothing
            }
            
            if(str!=null){
                ....
            }else{
                str = input.getStringByField("action");
                if("refreshCache".equals(str))
                    counters.clear();
            }
        //Set the tuple as Acknowledge
        collector.ack(input);
}
----

As we can see we've added an "if" to check if the word field is into the tuple, if not we'll asume that is an action.

So in the topology definition we'll specify to the word-counter bolt that it has two streams and the signals-spout stream must be sent to all count-word bolts as we can see below:

[source,java]
----
builder.setBolt("word-counter", new WordCounter(),2)
            .fieldsGrouping("word-normalizer", new Fields("word"))
            .allGrouping("signals-spout");
----

The implementation of signals-spout can be found into the link:https://github.com/storm-book/examples-ch03-topologies[git repository]

==== Custom Grouping
With the custom grouping we'll have de capability to create our own streams grouping implementing the *backtype.storm.grouping.CustomStreamGrouping* interface, using custom groupings we'll have the power to decide on each tuple which (zero, one or more) bolt will receive the tuple. Using other time our word count example we'll modfy it to group by the hash of the first leter of the word, so all words that start with the same leter will be received by the same bolt.

[source,java]
----
        builder.setBolt("word-counter", new WordCounter(),2)
            .customGrouping("word-normalizer", new CustomStreamGrouping() {
                int numTasks=0;
                @Override
                public List<Integer> taskIndices(Tuple tuple) {
                    List<Integer> boltsIds = new ArrayList<Integer>();
                    String str = tuple.getString(0).trim().toUpperCase();
                    if(str.isEmpty())
                        boltsIds.add(0);
                    else
                        boltsIds.add(str.charAt(0) % numTasks);
                    return boltsIds;
                }
                @Override
                public void prepare(int numTasks) {
                    this.numTasks = numTasks; 
                }
            });
----

Here we can see a very simple implementation of *CustomStreamGrouping* where we use the amount of tasks to take module on the first char and select which bolt will receive the tuple

==== Other groupings
text

=== LocalCluster vs StormSubmitter
text

=== Monitoring a Topology
text

=== DRPC Topologies
text

=== Conclusions
text

