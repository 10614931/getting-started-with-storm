[[basics]]
== Basics
If you are reading this is because you somehow heard about Storm and you are interested in understanding better what it does, how can you use it to solve different problems, and how it works.

This book will get you started with Storm in a very straightforward and easy way.

The first chapters will give you a general overview on the different technologies involved, some concepts you should manage so we all speak the same language and how to install and configure storm. The second half of the book will get you deep into *Spouts*, *Bolts* and *Topologies* (you will learn about this in a moment). The last chapters were destined to address some more advanced features that we considered very important and interesting, like using Storm with languganges that are not JVM based or testing, which can get very tricky and complex and it is very important.

Maybe the very first thing that you should know about Storm is that it is a distributed, reliable, and fault-tolerant stream processing system. This means that the input of a Storm cluster is a stream of data handled by a node called *Spout*, that will pass the data as it arrives to a another node called *Bolt* which will transform this data in some way and leave it somewhere so the user can access it or usually will pass it to some other *Bolt*.
You can imagine this is a chain of nodes (bolts), where each one make some kind of transformation to the data brought by the *Spout*.

To illustrate this even better lets imagine a very simple example. 

Last night I was watching news and at some point they started to talk about politicians and their different opinions. They kept repeating different names and I wanted to know if somehow they were saying the same amount of time all the different names or if there was any suspicious inclination.
If you imagine the subtitles of what they were saying as your input stream of data, than you have a *Spout* that might read this from a file, receive it via HTTP or a socket, etc. As lines of text arrives, the *Spout* hand this to a *Bolt* which will separate lines of text to words. So at this stage a stream of text is converted to a stream of words. After that another *Bolt* will compare each word to a predefined list of politician names, on every match it can increase a counter for that name in a database.
Whenever you want to see the results you just query that database, which will be updated in realtime as data arrives in.

Even if this is a very basic example I guess you can see how powerfull it can be. Now if we take all the nodes (Spout and Bolts) and their connections you have a Topology. And to make it even more magical, imagine defining very easily the amount of paralelism that you want for each Bolt and Spout, so you can scale your topology very easily. Amazing! Right?

.So which are typical use cases for Storm?
. Processing streams: As we mentioned is the very basic example and unlike other ways of processing streams, with Storm there's no need of queues and workers.
. Continuous computation: You can send to clients data continuously so they can update and show realtime results, like site metrics, etc.
. Distributed remote processing: If you have a very intense operation, you can use Storm to paralelize it.

=== Components of Storm

In a Storm cluster you run *Topologies* and those *Topologies* run forever.

There are two kind of nodes in a Storm cluster: master nodes and worker nodes. The master nodes run a daemon called Nimbus which is responsible for distributing code around the cluster, assigning tasks to each worker node of the cluster and monitoring for failures. On the other hand the worker nodes run a daemon called Supervisor and are responsibe for executing a portion of a *Topology*.
This mean that a *Topology* in Storm runs across many different worker nodes on different machines.

There is somekind of coordination happening between master and worker nodes which is taken care of by a *Zookeeper* cluster. That leads to a very important design decision: both Nimbus and Supervisor daemons are stateless, which means that if they fail or you kill them they'll start back like nothing happened.

Underneath Storm make use of 0mq (zeromq) which is a very advanced embeddable networking library which provide wonderfull features that make Storm possible.

=== Properties of Storm

From all these design concepts and decision there are some really nice properties that make Storm unique.

. Very simple de program: If you ever tried doing realtime processing from scratch you'll understand how painful it can become. With Storm complexity is reduced dramatically.
. Support for multiple programming languages: It is easier to develop in a JVM based language, but Storm support any language as long as you use or implement a small library that as a intermediaty between the selected language and Storm.
. Fault-tolerant: Storm cluster will take care of workers going down and reassign tasks when necessary.
. Scalable: All you need to do in order to scale is add more machines to the cluster. Storm will reassign tasks to those new machines as they become available.
. Reliable: All messages are guaranteed to be processed at least once. If you had errors messages might be processed more than once. But you will never loose any message.
. Fast: Speed was one of the concept the drove Storm design decisions.
